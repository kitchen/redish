// Code generated by protoc-gen-go. DO NOT EDIT.
// source: redish.proto

package redish

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Key struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{0}
}

func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type KeyValue struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{1}
}

func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValue.Unmarshal(m, b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return xxx_messageInfo_KeyValue.Size(m)
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type KeyList struct {
	Keys                 []*Key   `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyList) Reset()         { *m = KeyList{} }
func (m *KeyList) String() string { return proto.CompactTextString(m) }
func (*KeyList) ProtoMessage()    {}
func (*KeyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{2}
}

func (m *KeyList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyList.Unmarshal(m, b)
}
func (m *KeyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyList.Marshal(b, m, deterministic)
}
func (m *KeyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyList.Merge(m, src)
}
func (m *KeyList) XXX_Size() int {
	return xxx_messageInfo_KeyList.Size(m)
}
func (m *KeyList) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyList.DiscardUnknown(m)
}

var xxx_messageInfo_KeyList proto.InternalMessageInfo

func (m *KeyList) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

type KeyValueList struct {
	Pairs                []*KeyValue `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *KeyValueList) Reset()         { *m = KeyValueList{} }
func (m *KeyValueList) String() string { return proto.CompactTextString(m) }
func (*KeyValueList) ProtoMessage()    {}
func (*KeyValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{3}
}

func (m *KeyValueList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValueList.Unmarshal(m, b)
}
func (m *KeyValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValueList.Marshal(b, m, deterministic)
}
func (m *KeyValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValueList.Merge(m, src)
}
func (m *KeyValueList) XXX_Size() int {
	return xxx_messageInfo_KeyValueList.Size(m)
}
func (m *KeyValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValueList.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValueList proto.InternalMessageInfo

func (m *KeyValueList) GetPairs() []*KeyValue {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type SingleValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SingleValue) Reset()         { *m = SingleValue{} }
func (m *SingleValue) String() string { return proto.CompactTextString(m) }
func (*SingleValue) ProtoMessage()    {}
func (*SingleValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{4}
}

func (m *SingleValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SingleValue.Unmarshal(m, b)
}
func (m *SingleValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SingleValue.Marshal(b, m, deterministic)
}
func (m *SingleValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleValue.Merge(m, src)
}
func (m *SingleValue) XXX_Size() int {
	return xxx_messageInfo_SingleValue.Size(m)
}
func (m *SingleValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleValue.DiscardUnknown(m)
}

var xxx_messageInfo_SingleValue proto.InternalMessageInfo

func (m *SingleValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type IntValue struct {
	Value                int64    `protobuf:"zigzag64,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntValue) Reset()         { *m = IntValue{} }
func (m *IntValue) String() string { return proto.CompactTextString(m) }
func (*IntValue) ProtoMessage()    {}
func (*IntValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{5}
}

func (m *IntValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IntValue.Unmarshal(m, b)
}
func (m *IntValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntValue.Marshal(b, m, deterministic)
}
func (m *IntValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntValue.Merge(m, src)
}
func (m *IntValue) XXX_Size() int {
	return xxx_messageInfo_IntValue.Size(m)
}
func (m *IntValue) XXX_DiscardUnknown() {
	xxx_messageInfo_IntValue.DiscardUnknown(m)
}

var xxx_messageInfo_IntValue proto.InternalMessageInfo

func (m *IntValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type KeyIntValue struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                int64    `protobuf:"zigzag64,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyIntValue) Reset()         { *m = KeyIntValue{} }
func (m *KeyIntValue) String() string { return proto.CompactTextString(m) }
func (*KeyIntValue) ProtoMessage()    {}
func (*KeyIntValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{6}
}

func (m *KeyIntValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyIntValue.Unmarshal(m, b)
}
func (m *KeyIntValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyIntValue.Marshal(b, m, deterministic)
}
func (m *KeyIntValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyIntValue.Merge(m, src)
}
func (m *KeyIntValue) XXX_Size() int {
	return xxx_messageInfo_KeyIntValue.Size(m)
}
func (m *KeyIntValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyIntValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyIntValue proto.InternalMessageInfo

func (m *KeyIntValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyIntValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type ValueList struct {
	Values               []*SingleValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ValueList) Reset()         { *m = ValueList{} }
func (m *ValueList) String() string { return proto.CompactTextString(m) }
func (*ValueList) ProtoMessage()    {}
func (*ValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{7}
}

func (m *ValueList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ValueList.Unmarshal(m, b)
}
func (m *ValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ValueList.Marshal(b, m, deterministic)
}
func (m *ValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueList.Merge(m, src)
}
func (m *ValueList) XXX_Size() int {
	return xxx_messageInfo_ValueList.Size(m)
}
func (m *ValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueList.DiscardUnknown(m)
}

var xxx_messageInfo_ValueList proto.InternalMessageInfo

func (m *ValueList) GetValues() []*SingleValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// distinct from KeyValue because redis SET command has more features that this doesn't support yet
type SetRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetRequest) Reset()         { *m = SetRequest{} }
func (m *SetRequest) String() string { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()    {}
func (*SetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{8}
}

func (m *SetRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetRequest.Unmarshal(m, b)
}
func (m *SetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetRequest.Marshal(b, m, deterministic)
}
func (m *SetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest.Merge(m, src)
}
func (m *SetRequest) XXX_Size() int {
	return xxx_messageInfo_SetRequest.Size(m)
}
func (m *SetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest proto.InternalMessageInfo

func (m *SetRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetRequest) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type OK struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OK) Reset()         { *m = OK{} }
func (m *OK) String() string { return proto.CompactTextString(m) }
func (*OK) ProtoMessage()    {}
func (*OK) Descriptor() ([]byte, []int) {
	return fileDescriptor_d30173c04f457c8e, []int{9}
}

func (m *OK) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OK.Unmarshal(m, b)
}
func (m *OK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OK.Marshal(b, m, deterministic)
}
func (m *OK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OK.Merge(m, src)
}
func (m *OK) XXX_Size() int {
	return xxx_messageInfo_OK.Size(m)
}
func (m *OK) XXX_DiscardUnknown() {
	xxx_messageInfo_OK.DiscardUnknown(m)
}

var xxx_messageInfo_OK proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Key)(nil), "redish.Key")
	proto.RegisterType((*KeyValue)(nil), "redish.KeyValue")
	proto.RegisterType((*KeyList)(nil), "redish.KeyList")
	proto.RegisterType((*KeyValueList)(nil), "redish.KeyValueList")
	proto.RegisterType((*SingleValue)(nil), "redish.SingleValue")
	proto.RegisterType((*IntValue)(nil), "redish.IntValue")
	proto.RegisterType((*KeyIntValue)(nil), "redish.KeyIntValue")
	proto.RegisterType((*ValueList)(nil), "redish.ValueList")
	proto.RegisterType((*SetRequest)(nil), "redish.SetRequest")
	proto.RegisterType((*OK)(nil), "redish.OK")
}

func init() { proto.RegisterFile("redish.proto", fileDescriptor_d30173c04f457c8e) }

var fileDescriptor_d30173c04f457c8e = []byte{
	// 393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xed, 0x6a, 0xe2, 0x40,
	0x14, 0x4d, 0xcc, 0x98, 0xd5, 0x1b, 0x61, 0xdd, 0x51, 0x58, 0xf1, 0xcf, 0xca, 0x2c, 0xac, 0x5f,
	0xbb, 0xc2, 0xda, 0x0f, 0xfa, 0x0a, 0x25, 0x05, 0x21, 0x42, 0xff, 0x6b, 0xbd, 0xd8, 0x60, 0x8c,
	0x36, 0x33, 0x96, 0xce, 0x7b, 0xf6, 0x81, 0xca, 0x4c, 0x9c, 0x34, 0x56, 0xa5, 0xe9, 0xbf, 0xcc,
	0xbd, 0xe7, 0x9c, 0x39, 0x73, 0xee, 0x25, 0x50, 0x4b, 0x70, 0x11, 0xf2, 0xc7, 0xd1, 0x36, 0xd9,
	0x88, 0x0d, 0x75, 0xd3, 0x13, 0xfb, 0x09, 0x8e, 0x8f, 0x92, 0xd6, 0xc1, 0x59, 0xa1, 0x6c, 0xd9,
	0x1d, 0xbb, 0x57, 0x0d, 0xd4, 0x27, 0x1b, 0x43, 0xc5, 0x47, 0x79, 0x3f, 0x8b, 0x76, 0x78, 0xdc,
	0xa5, 0x4d, 0x28, 0x3f, 0xab, 0x56, 0xab, 0xa4, 0x6b, 0xe9, 0x81, 0x0d, 0xe0, 0x9b, 0x8f, 0xf2,
	0x2e, 0xe4, 0x82, 0xfe, 0x02, 0xb2, 0x42, 0xc9, 0x5b, 0x76, 0xc7, 0xe9, 0x79, 0x63, 0x6f, 0xb4,
	0xbf, 0xdc, 0x47, 0x19, 0xe8, 0x06, 0xbb, 0x86, 0x9a, 0xd1, 0xd7, 0x84, 0x3f, 0x50, 0xde, 0xce,
	0xc2, 0xc4, 0x30, 0xea, 0x39, 0x86, 0x06, 0x05, 0x69, 0x9b, 0xfd, 0x06, 0x6f, 0x1a, 0xc6, 0xcb,
	0x08, 0x53, 0x6b, 0x99, 0x11, 0x3b, 0x6f, 0xa4, 0x03, 0x95, 0xdb, 0x58, 0x9c, 0x40, 0x50, 0x83,
	0xb8, 0x02, 0xcf, 0x47, 0x99, 0x81, 0x3e, 0x79, 0x61, 0x46, 0xbb, 0x81, 0xea, 0xbb, 0xe5, 0x21,
	0xb8, 0xba, 0x6a, 0x3c, 0x37, 0x8c, 0xe7, 0x9c, 0xc1, 0x60, 0x0f, 0x61, 0x97, 0x00, 0x53, 0x14,
	0x01, 0x3e, 0xed, 0x90, 0x8b, 0xc2, 0x89, 0x12, 0x28, 0x4d, 0xfc, 0xf1, 0x2b, 0x01, 0x37, 0xd0,
	0xd2, 0xb4, 0x0f, 0xce, 0x12, 0x05, 0xcd, 0x07, 0xda, 0x3e, 0x75, 0x2f, 0xb3, 0x68, 0x17, 0x1c,
	0x8e, 0x82, 0xd2, 0xac, 0x9b, 0x5d, 0xdf, 0x06, 0x53, 0x9b, 0xf8, 0xcc, 0xa2, 0x43, 0x20, 0x0b,
	0x8c, 0x90, 0x7e, 0xcf, 0x89, 0xaa, 0x07, 0xb6, 0xb3, 0x21, 0x98, 0x9c, 0x98, 0x45, 0xff, 0x81,
	0x8b, 0x2f, 0x21, 0x17, 0xbc, 0x18, 0xbc, 0x0b, 0x24, 0x8c, 0x1f, 0x92, 0x43, 0xc3, 0x67, 0x80,
	0x0b, 0x2c, 0x02, 0xfc, 0x0f, 0xae, 0x52, 0x9c, 0x4b, 0xda, 0xc8, 0x41, 0x0d, 0xe0, 0x1c, 0x45,
	0x69, 0x7f, 0x85, 0xd2, 0x07, 0x97, 0x8b, 0x24, 0xc2, 0xb8, 0x90, 0xa1, 0x25, 0x0a, 0x15, 0xf5,
	0xd1, 0xd2, 0x9e, 0x1b, 0xcd, 0x5f, 0x20, 0x6b, 0x35, 0xc6, 0xa3, 0x08, 0x7f, 0x98, 0x42, 0xb6,
	0x65, 0xcc, 0xa2, 0x03, 0x20, 0x6b, 0x25, 0xdf, 0xfc, 0x28, 0xaf, 0x29, 0x87, 0xb3, 0x1c, 0x00,
	0x11, 0x72, 0x8b, 0x45, 0x16, 0x64, 0xee, 0xea, 0x5f, 0xc1, 0xc5, 0x5b, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xd3, 0x08, 0x0b, 0xf7, 0x1a, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RedishClient is the client API for Redish service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RedishClient interface {
	// https://redis.io/commands
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*SingleValue, error)
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*OK, error)
	// has to be dele not del because python del is a keyword
	Dele(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*IntValue, error)
	Exists(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*IntValue, error)
	Incr(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	Decr(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	Incrby(ctx context.Context, in *KeyIntValue, opts ...grpc.CallOption) (*IntValue, error)
	Decrby(ctx context.Context, in *KeyIntValue, opts ...grpc.CallOption) (*IntValue, error)
	Strlen(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error)
	Getset(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*SingleValue, error)
	Mget(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*ValueList, error)
	Mset(ctx context.Context, in *KeyValueList, opts ...grpc.CallOption) (*OK, error)
	Type(ctx context.Context, in *Key, opts ...grpc.CallOption) (*SingleValue, error)
}

type redishClient struct {
	cc *grpc.ClientConn
}

func NewRedishClient(cc *grpc.ClientConn) RedishClient {
	return &redishClient{cc}
}

func (c *redishClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*SingleValue, error) {
	out := new(SingleValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*OK, error) {
	out := new(OK)
	err := c.cc.Invoke(ctx, "/redish.Redish/set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Dele(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/dele", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Exists(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Incr(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/incr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Decr(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/decr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Incrby(ctx context.Context, in *KeyIntValue, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/incrby", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Decrby(ctx context.Context, in *KeyIntValue, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/decrby", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Strlen(ctx context.Context, in *Key, opts ...grpc.CallOption) (*IntValue, error) {
	out := new(IntValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/strlen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Getset(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*SingleValue, error) {
	out := new(SingleValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/getset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Mget(ctx context.Context, in *KeyList, opts ...grpc.CallOption) (*ValueList, error) {
	out := new(ValueList)
	err := c.cc.Invoke(ctx, "/redish.Redish/mget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Mset(ctx context.Context, in *KeyValueList, opts ...grpc.CallOption) (*OK, error) {
	out := new(OK)
	err := c.cc.Invoke(ctx, "/redish.Redish/mset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redishClient) Type(ctx context.Context, in *Key, opts ...grpc.CallOption) (*SingleValue, error) {
	out := new(SingleValue)
	err := c.cc.Invoke(ctx, "/redish.Redish/type", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RedishServer is the server API for Redish service.
type RedishServer interface {
	// https://redis.io/commands
	Get(context.Context, *Key) (*SingleValue, error)
	Set(context.Context, *SetRequest) (*OK, error)
	// has to be dele not del because python del is a keyword
	Dele(context.Context, *KeyList) (*IntValue, error)
	Exists(context.Context, *KeyList) (*IntValue, error)
	Incr(context.Context, *Key) (*IntValue, error)
	Decr(context.Context, *Key) (*IntValue, error)
	Incrby(context.Context, *KeyIntValue) (*IntValue, error)
	Decrby(context.Context, *KeyIntValue) (*IntValue, error)
	Strlen(context.Context, *Key) (*IntValue, error)
	Getset(context.Context, *KeyValue) (*SingleValue, error)
	Mget(context.Context, *KeyList) (*ValueList, error)
	Mset(context.Context, *KeyValueList) (*OK, error)
	Type(context.Context, *Key) (*SingleValue, error)
}

// UnimplementedRedishServer can be embedded to have forward compatible implementations.
type UnimplementedRedishServer struct {
}

func (*UnimplementedRedishServer) Get(ctx context.Context, req *Key) (*SingleValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedRedishServer) Set(ctx context.Context, req *SetRequest) (*OK, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedRedishServer) Dele(ctx context.Context, req *KeyList) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dele not implemented")
}
func (*UnimplementedRedishServer) Exists(ctx context.Context, req *KeyList) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (*UnimplementedRedishServer) Incr(ctx context.Context, req *Key) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Incr not implemented")
}
func (*UnimplementedRedishServer) Decr(ctx context.Context, req *Key) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decr not implemented")
}
func (*UnimplementedRedishServer) Incrby(ctx context.Context, req *KeyIntValue) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Incrby not implemented")
}
func (*UnimplementedRedishServer) Decrby(ctx context.Context, req *KeyIntValue) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrby not implemented")
}
func (*UnimplementedRedishServer) Strlen(ctx context.Context, req *Key) (*IntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Strlen not implemented")
}
func (*UnimplementedRedishServer) Getset(ctx context.Context, req *KeyValue) (*SingleValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Getset not implemented")
}
func (*UnimplementedRedishServer) Mget(ctx context.Context, req *KeyList) (*ValueList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mget not implemented")
}
func (*UnimplementedRedishServer) Mset(ctx context.Context, req *KeyValueList) (*OK, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mset not implemented")
}
func (*UnimplementedRedishServer) Type(ctx context.Context, req *Key) (*SingleValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Type not implemented")
}

func RegisterRedishServer(s *grpc.Server, srv RedishServer) {
	s.RegisterService(&_Redish_serviceDesc, srv)
}

func _Redish_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Get(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Dele_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Dele(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Dele",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Dele(ctx, req.(*KeyList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Exists(ctx, req.(*KeyList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Incr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Incr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Incr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Incr(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Decr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Decr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Decr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Decr(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Incrby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyIntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Incrby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Incrby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Incrby(ctx, req.(*KeyIntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Decrby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyIntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Decrby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Decrby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Decrby(ctx, req.(*KeyIntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Strlen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Strlen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Strlen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Strlen(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Getset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Getset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Getset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Getset(ctx, req.(*KeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Mget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Mget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Mget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Mget(ctx, req.(*KeyList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Mset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Mset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Mset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Mset(ctx, req.(*KeyValueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Redish_Type_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedishServer).Type(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redish.Redish/Type",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedishServer).Type(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

var _Redish_serviceDesc = grpc.ServiceDesc{
	ServiceName: "redish.Redish",
	HandlerType: (*RedishServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get",
			Handler:    _Redish_Get_Handler,
		},
		{
			MethodName: "set",
			Handler:    _Redish_Set_Handler,
		},
		{
			MethodName: "dele",
			Handler:    _Redish_Dele_Handler,
		},
		{
			MethodName: "exists",
			Handler:    _Redish_Exists_Handler,
		},
		{
			MethodName: "incr",
			Handler:    _Redish_Incr_Handler,
		},
		{
			MethodName: "decr",
			Handler:    _Redish_Decr_Handler,
		},
		{
			MethodName: "incrby",
			Handler:    _Redish_Incrby_Handler,
		},
		{
			MethodName: "decrby",
			Handler:    _Redish_Decrby_Handler,
		},
		{
			MethodName: "strlen",
			Handler:    _Redish_Strlen_Handler,
		},
		{
			MethodName: "getset",
			Handler:    _Redish_Getset_Handler,
		},
		{
			MethodName: "mget",
			Handler:    _Redish_Mget_Handler,
		},
		{
			MethodName: "mset",
			Handler:    _Redish_Mset_Handler,
		},
		{
			MethodName: "type",
			Handler:    _Redish_Type_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "redish.proto",
}
